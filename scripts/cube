#!/bin/bash
# cube - Agent Cube CLI
# A command-line interface for orchestrating parallel LLM coding workflows

set -e

VERSION="1.0.0"
# Resolve symlink to get actual script location
SCRIPT_SOURCE="${BASH_SOURCE[0]}"
while [ -L "$SCRIPT_SOURCE" ]; do
  SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_SOURCE")" && pwd)"
  SCRIPT_SOURCE="$(readlink "$SCRIPT_SOURCE")"
  [[ $SCRIPT_SOURCE != /* ]] && SCRIPT_SOURCE="$SCRIPT_DIR/$SCRIPT_SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_SOURCE")" && pwd)"
PROJECT_ROOT="$(pwd)"

# Ensure ~/.local/bin is in PATH for cursor-agent
export PATH="$HOME/.local/bin:$PATH"

# Auto-update cube if running from a git repo on main branch
auto_update_cube() {
    local cube_repo_root="$(cd "$SCRIPT_DIR/.." && git rev-parse --show-toplevel 2>/dev/null)"
    if [ -n "$cube_repo_root" ]; then
        local current_branch=$(cd "$cube_repo_root" && git rev-parse --abbrev-ref HEAD 2>/dev/null)
        if [ "$current_branch" = "main" ] || [ "$current_branch" = "master" ]; then
            cd "$cube_repo_root" || return
            git fetch origin "$current_branch" --quiet 2>/dev/null
            local local_commit=$(git rev-parse HEAD)
            local remote_commit=$(git rev-parse "origin/$current_branch" 2>/dev/null)
            
            if [ -n "$remote_commit" ] && [ "$local_commit" != "$remote_commit" ]; then
                echo -e "${CYAN}üîÑ Updating cube...${NC}"
                if git pull --quiet origin "$current_branch" 2>/dev/null; then
                    echo -e "${GREEN}‚úÖ Cube updated successfully${NC}"
                    echo ""
                fi
            fi
            cd "$PROJECT_ROOT" || return
        fi
    fi
}

auto_update_cube

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Helper functions
print_error() {
    echo -e "${RED}‚ùå Error: $1${NC}" >&2
}

print_success() {
    echo -e "${GREEN}‚úÖ $1${NC}"
}

print_info() {
    echo -e "${CYAN}‚ÑπÔ∏è  $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"
}

# Check if cursor-agent is installed
check_cursor_agent() {
    if ! command -v cursor-agent &> /dev/null; then
        print_error "cursor-agent CLI is not installed"
        echo ""
        echo "Install cursor-agent:"
        echo -e "  ${GREEN}npm install -g @cursor/cli${NC}"
        echo ""
        echo "Or add to your PATH if already installed:"
        echo -e "  ${YELLOW}export PATH=\"\$HOME/.local/bin:\$PATH\"${NC}"
        echo ""
        echo "After installation, authenticate with:"
        echo -e "  ${GREEN}cursor-agent login${NC}"
        echo ""
        exit 1
    fi
    
    # Check if authenticated
    if ! cursor-agent --help &> /dev/null; then
        print_warning "cursor-agent may not be authenticated"
        echo ""
        echo "Run: ${GREEN}cursor-agent login${NC}"
        echo ""
    fi
}

# Show help
show_help() {
    echo -e "${CYAN}cube${NC} - Agent Cube CLI ${GREEN}v${VERSION}${NC}"
    echo ""
    echo -e "${YELLOW}USAGE:${NC}"
    echo "  cube <command> [options]"
    echo ""
    echo -e "${YELLOW}COMMANDS:${NC}"
    echo -e "  ${GREEN}writers${NC}    <task-id> <prompt-file> [--resume]"
    echo "             Launch dual writers for a task"
    echo "             Use --resume to continue existing sessions"
    echo "             Example: cube writers 02-error-handler implementation/phase-02/orchestration/02-error-handler-writer-prompt.md"
    echo ""
    echo -e "  ${GREEN}panel${NC}      <task-id> <panel-prompt-file> [review-type] [--resume]"
    echo "             Launch 3-judge panel for initial solution selection"
    echo "             Review types: initial (default)"
    echo "             Use --resume to continue existing judge sessions"
    echo "             Example: cube panel 02-error-handler implementation/phase-02/orchestration/02-error-handler-panel-prompt.md"
    echo ""
    echo -e "  ${GREEN}peer-review${NC} <task-id> <peer-review-prompt-file> [--fresh]"
    echo "             Resume original 3 judges from initial panel for peer review (default)"
    echo "             Use --fresh to launch new judges instead of resuming"
    echo "             Example: cube peer-review 02-error-handler implementation/phase-02/orchestration/02-error-handler-peer-review-prompt.md"
    echo ""
    echo -e "  ${GREEN}feedback${NC}   <writer> <task-id> <feedback-file>"
    echo "             Send feedback to a writer (resumes their session)"
    echo "             Writer: sonnet | codex"
    echo "             Example: cube feedback codex 02-error-handler implementation/phase-02/orchestration/02-error-handler-synthesis-instructions.md"
    echo ""
    echo -e "  ${GREEN}orchestrate${NC} prompt <task-file> [--copy]"
    echo "             Generate orchestrator prompt for autonomous workflow execution"
    echo "             Use --copy to copy to clipboard (paste into Cursor UI)"
    echo "             Example: cube orchestrate prompt implementation/phase-01/tasks/01-api-client.md --copy"
    echo ""
    echo -e "  ${GREEN}resume${NC}     <writer|judge> <task-id> <message>"
    echo "             Resume a writer or judge session with a message"
    echo "             Example: cube resume writer-codex 02-error-handler \"Please fix the lint errors\""
    echo "             Example: cube resume judge-1 02-error-handler \"Review the updated solution\""
    echo ""
    echo -e "  ${GREEN}status${NC}     <task-id>"
    echo "             Show status of a task (sessions, branches, etc.)"
    echo "             Example: cube status 02-error-handler"
    echo ""
    echo -e "  ${GREEN}sessions${NC}"
    echo "             List all active sessions"
    echo "             Example: cube sessions"
    echo ""
    echo -e "  ${GREEN}install${NC}"
    echo "             Install cube CLI to your PATH"
    echo "             Example: cube install"
    echo ""
    echo -e "  ${GREEN}version${NC}"
    echo "             Show version information"
    echo ""
    echo -e "  ${GREEN}help${NC}"
    echo "             Show this help message"
    echo ""
    echo -e "${YELLOW}GLOBAL OPTIONS:${NC}"
    echo "  -h, --help     Show help"
    echo "  -v, --version  Show version"
    echo ""
    echo -e "${YELLOW}EXAMPLES:${NC}"
    echo "  # Start dual writers for a new task"
    echo "  cube writers 03-auth-middleware implementation/phase-03/orchestration/03-auth-middleware-writer-prompt.md"
    echo ""
    echo "  # Launch judge panel for initial review"
    echo "  cube panel 03-auth-middleware implementation/phase-03/orchestration/03-auth-middleware-panel-prompt.md"
    echo ""
    echo "  # Send synthesis instructions to winner"
    echo "  cube feedback codex 03-auth-middleware implementation/phase-03/orchestration/03-auth-middleware-synthesis.md"
    echo ""
    echo "  # Launch peer review"
    echo "  cube peer-review 03-auth-middleware implementation/phase-03/orchestration/03-auth-middleware-peer-review.md"
    echo ""
    echo -e "${YELLOW}DOCUMENTATION:${NC}"
    echo "  See AGENT_CUBE.md and AGENT_CUBE_AUTOMATION.md for full workflow details"
    echo ""
}

# Show version
show_version() {
    echo -e "${CYAN}cube${NC} version ${GREEN}${VERSION}${NC}"
    echo "Agent Cube - Parallel LLM Coding Workflow Orchestrator"
}

# Install cube to PATH
install_cube() {
    print_info "Installing cube CLI..."
    
    # Check if ~/.local/bin exists
    if [ ! -d "$HOME/.local/bin" ]; then
        print_warning "Creating ~/.local/bin directory"
        mkdir -p "$HOME/.local/bin"
    fi
    
    # Create symlink
    local target="$HOME/.local/bin/cube"
    if [ -L "$target" ] || [ -f "$target" ]; then
        print_warning "Removing existing cube installation"
        rm -f "$target"
    fi
    
    ln -s "$SCRIPT_DIR/cube" "$target"
    chmod +x "$SCRIPT_DIR/cube"
    
    print_success "Cube CLI installed to $target"
    
    # Check if ~/.local/bin is in PATH
    if [[ ":$PATH:" != *":$HOME/.local/bin:"* ]]; then
        print_warning "~/.local/bin is not in your PATH"
        echo ""
        echo "Add this line to your ~/.zshrc or ~/.bashrc:"
        echo -e "${YELLOW}export PATH=\"\$HOME/.local/bin:\$PATH\"${NC}"
        echo ""
        echo "Then run: source ~/.zshrc (or ~/.bashrc)"
    else
        print_success "~/.local/bin is already in your PATH"
        echo ""
        echo -e "You can now run: ${GREEN}cube --help${NC}"
    fi
}

# Launch dual writers
cmd_writers() {
    local task_id="$1"
    local prompt_file="$2"
    local resume_flag="$3"
    
    if [ -z "$task_id" ] || [ -z "$prompt_file" ]; then
        print_error "Usage: cube writers <task-id> <prompt-file> [--resume]"
        echo "Example: cube writers 02-error-handler implementation/phase-02/orchestration/02-error-handler-writer-prompt.md"
        exit 1
    fi
    
    if [ ! -f "$PROJECT_ROOT/$prompt_file" ]; then
        print_error "Prompt file not found: $prompt_file"
        exit 1
    fi
    
    check_cursor_agent
    
    # Check if --resume flag is used
    if [ "$resume_flag" = "--resume" ]; then
        local session_a="$PROJECT_ROOT/.agent-sessions/WRITER_A_${task_id}_SESSION_ID.txt"
        local session_b="$PROJECT_ROOT/.agent-sessions/WRITER_B_${task_id}_SESSION_ID.txt"
        
        if [ ! -f "$session_a" ] || [ ! -f "$session_b" ]; then
            print_error "Cannot resume: existing sessions not found for task: $task_id"
            echo ""
            echo "Session files expected:"
            echo "  $session_a"
            echo "  $session_b"
            echo ""
            echo "Run without --resume to start new sessions, or use 'cube sessions' to see available sessions"
            exit 1
        fi
        
        print_info "Resuming dual writers for task: $task_id"
        export RESUME_MODE="true"
    else
        print_info "Launching dual writers for task: $task_id"
    fi
    
    exec "$SCRIPT_DIR/automation/launch-dual-writers.sh" "$task_id" "$prompt_file"
}

# Launch judge panel
cmd_panel() {
    local task_id="$1"
    local panel_prompt="$2"
    local arg3="$3"
    local arg4="$4"
    
    if [ -z "$task_id" ] || [ -z "$panel_prompt" ]; then
        print_error "Usage: cube panel <task-id> <panel-prompt-file> [review-type] [--resume]"
        echo "Example: cube panel 02-error-handler implementation/phase-02/orchestration/02-error-handler-panel-prompt.md"
        exit 1
    fi
    
    if [ ! -f "$PROJECT_ROOT/$panel_prompt" ]; then
        print_error "Panel prompt file not found: $panel_prompt"
        exit 1
    fi
    
    # Parse arguments - could be review-type and/or --resume in any order
    local review_type="initial"
    local resume_flag=""
    
    if [ "$arg3" = "--resume" ]; then
        resume_flag="--resume"
    elif [ -n "$arg3" ] && [ "$arg3" != "--resume" ]; then
        review_type="$arg3"
    fi
    
    if [ "$arg4" = "--resume" ]; then
        resume_flag="--resume"
    elif [ -n "$arg4" ] && [ "$arg4" != "--resume" ]; then
        review_type="$arg4"
    fi
    
    check_cursor_agent
    
    # Check if --resume flag is used
    if [ "$resume_flag" = "--resume" ]; then
        local session_1="$PROJECT_ROOT/.agent-sessions/JUDGE_1_${task_id}_${review_type}_SESSION_ID.txt"
        local session_2="$PROJECT_ROOT/.agent-sessions/JUDGE_2_${task_id}_${review_type}_SESSION_ID.txt"
        local session_3="$PROJECT_ROOT/.agent-sessions/JUDGE_3_${task_id}_${review_type}_SESSION_ID.txt"
        
        if [ ! -f "$session_1" ] || [ ! -f "$session_2" ] || [ ! -f "$session_3" ]; then
            print_error "Cannot resume: existing judge sessions not found for task: $task_id (review type: $review_type)"
            echo ""
            echo "Session files expected:"
            echo "  $session_1"
            echo "  $session_2"
            echo "  $session_3"
            echo ""
            echo "Run without --resume to start new sessions, or use 'cube sessions' to see available sessions"
            exit 1
        fi
        
        print_info "Resuming judge panel for task: $task_id (review type: $review_type)"
        export RESUME_MODE="true"
    else
        print_info "Launching judge panel for task: $task_id (review type: $review_type)"
    fi
    
    exec "$SCRIPT_DIR/automation/launch-judge-panel.sh" "$task_id" "$panel_prompt" "$review_type"
}

# Send feedback to writer
cmd_feedback() {
    local writer="$1"
    local task_id="$2"
    local feedback_file="$3"
    
    if [ -z "$writer" ] || [ -z "$task_id" ] || [ -z "$feedback_file" ]; then
        print_error "Usage: cube feedback <writer> <task-id> <feedback-file>"
        echo "Writer: sonnet | codex"
        echo "Example: cube feedback codex 02-error-handler implementation/phase-02/orchestration/02-error-handler-synthesis.md"
        exit 1
    fi
    
    # Normalize writer name
    local writer_letter=""
    local model=""
    case "$writer" in
        sonnet|writer-sonnet|a|A)
            writer="sonnet"
            writer_letter="A"
            model="sonnet-4.5-thinking"
            ;;
        codex|writer-codex|b|B)
            writer="codex"
            writer_letter="B"
            model="gpt-5-codex-high"
            ;;
        *)
            print_error "Invalid writer: $writer (must be 'sonnet' or 'codex')"
            exit 1
            ;;
    esac
    
    if [ ! -f "$PROJECT_ROOT/$feedback_file" ]; then
        print_error "Feedback file not found: $feedback_file"
        exit 1
    fi
    
    # Find worktree with task-id
    local project_name=$(basename "$PROJECT_ROOT")
    local worktree="$HOME/.cube/worktrees/$project_name/writer-${writer}-${task_id}"
    if [ ! -d "$worktree" ]; then
        print_error "Worktree not found: $worktree"
        print_info "Expected: writer-${writer}-${task_id}"
        exit 1
    fi
    
    # Find session ID
    local session_file="$PROJECT_ROOT/.agent-sessions/WRITER_${writer_letter}_${task_id}_SESSION_ID.txt"
    if [ ! -f "$session_file" ]; then
        print_error "Session ID not found: $session_file"
        print_info "Run 'cube sessions' to see available sessions"
        exit 1
    fi
    
    local session_id=$(cat "$session_file")
    
    # Read feedback from file
    local feedback_message=$(cat "$PROJECT_ROOT/$feedback_file")
    
    check_cursor_agent
    
    print_info "Sending feedback to writer-${writer} for task: $task_id"
    print_info "Session ID: $session_id"
    print_info "Feedback file: $feedback_file"
    
    # Export PROJECT_ROOT and SESSION_FILE_PATH so stream-agent.sh can save session immediately
    export PROJECT_ROOT
    export SESSION_FILE_PATH="$session_file"
    exec "$SCRIPT_DIR/automation/stream-agent.sh" "$worktree" --model "$model" --resume "$session_id" "$feedback_message"
}

# Show task status
cmd_status() {
    local task_id="$1"
    
    if [ -z "$task_id" ]; then
        print_error "Usage: cube status <task-id>"
        exit 1
    fi
    
    echo -e "${CYAN}üìä Task Status: ${YELLOW}$task_id${NC}"
    echo ""
    
    # Check branches
    echo -e "${GREEN}Branches:${NC}"
    git branch -r | grep "$task_id" || echo "  No branches found"
    echo ""
    
    # Check sessions
    echo -e "${GREEN}Sessions:${NC}"
    if [ -d "$PROJECT_ROOT/.agent-sessions" ]; then
        ls -1 "$PROJECT_ROOT/.agent-sessions" | grep "$task_id" || echo "  No sessions found"
    else
        echo "  No sessions directory"
    fi
    echo ""
    
    # Check worktrees
    echo -e "${GREEN}Worktrees:${NC}"
    git worktree list | grep "$task_id" || echo "  No worktrees found"
}

# List all sessions
cmd_sessions() {
    echo -e "${CYAN}üìã Active Sessions${NC}"
    echo ""
    
    if [ ! -d "$PROJECT_ROOT/.agent-sessions" ]; then
        print_warning "No sessions directory found"
        exit 0
    fi
    
    local count=0
    for file in "$PROJECT_ROOT/.agent-sessions"/*_SESSION_ID.txt; do
        if [ -f "$file" ]; then
            local name=$(basename "$file" _SESSION_ID.txt)
            local session_id=$(cat "$file")
            echo -e "${GREEN}${name}${NC}"
            echo -e "  Session ID: ${CYAN}${session_id}${NC}"
            
            # Show metadata if exists
            if [ -f "${file}.meta" ]; then
                local meta=$(head -1 "${file}.meta" | sed 's/^# //')
                echo "  ${meta}"
            fi
            echo ""
            ((count++))
        fi
    done
    
    if [ $count -eq 0 ]; then
        print_info "No active sessions found"
    else
        print_success "Found $count active session(s)"
    fi
}

# Resume a session
cmd_resume() {
    local target="$1"
    local task_id="$2"
    shift 2
    local message="$*"
    
    if [ -z "$target" ] || [ -z "$task_id" ] || [ -z "$message" ]; then
        print_error "Usage: cube resume <writer|judge> <task-id> <message>"
        echo "Example: cube resume writer-codex 02-error-handler \"Fix the lint errors\""
        exit 1
    fi
    
    # Normalize target
    local writer_name=""
    local writer_letter=""
    local model=""
    
    case "$target" in
        writer-sonnet|sonnet|a|A)
            writer_name="sonnet"
            writer_letter="A"
            model="sonnet-4.5-thinking"
            ;;
        writer-codex|codex|b|B)
            writer_name="codex"
            writer_letter="B"
            model="gpt-5-codex-high"
            ;;
        *)
            print_error "Invalid target: $target (must be writer-sonnet or writer-codex)"
            exit 1
            ;;
    esac
    
    # Find worktree with task-id
    local project_name=$(basename "$PROJECT_ROOT")
    local worktree="$HOME/.cube/worktrees/$project_name/writer-${writer_name}-${task_id}"
    if [ ! -d "$worktree" ]; then
        print_error "Worktree not found: $worktree"
        print_info "Expected: writer-${writer_name}-${task_id}"
        exit 1
    fi
    
    # Find session ID
    local session_file="$PROJECT_ROOT/.agent-sessions/WRITER_${writer_letter}_${task_id}_SESSION_ID.txt"
    if [ ! -f "$session_file" ]; then
        print_error "Session ID not found: $session_file"
        print_info "Run 'cube sessions' to see available sessions"
        exit 1
    fi
    
    local session_id=$(cat "$session_file")
    
    check_cursor_agent
    
    print_info "Resuming writer-${writer_name} for task: $task_id"
    print_info "Session ID: $session_id"
    print_info "Message: $message"
    
    # Export PROJECT_ROOT and SESSION_FILE_PATH so stream-agent.sh can save session immediately
    export PROJECT_ROOT
    export SESSION_FILE_PATH="$session_file"
    exec "$SCRIPT_DIR/automation/stream-agent.sh" "$worktree" --model "$model" --resume "$session_id" "$message"
}

# Peer review command - resume original judges from initial panel
cmd_peer_review() {
    local task_id="$1"
    local peer_review_prompt="$2"
    local fresh_flag="$3"
    
    if [ -z "$task_id" ] || [ -z "$peer_review_prompt" ]; then
        print_error "Task ID and peer review prompt file are required"
        echo ""
        echo "Usage: cube peer-review <task-id> <peer-review-prompt-file> [--fresh]"
        echo "Example: cube peer-review 02-error-handler implementation/phase-02/orchestration/02-error-handler-peer-review-prompt.md"
        exit 1
    fi
    
    if [ ! -f "$peer_review_prompt" ]; then
        print_error "Peer review prompt file not found: $peer_review_prompt"
        exit 1
    fi
    
    check_cursor_agent
    
    # Check if --fresh flag is used
    if [ "$fresh_flag" = "--fresh" ]; then
        print_info "Launching fresh judge panel for peer review of task: $task_id"
        export RESUME_MODE=""
        exec "$SCRIPT_DIR/automation/launch-judge-panel.sh" "$task_id" "$peer_review_prompt" "peer-review"
    fi
    
    # Default: resume original judges from initial panel
    local session_1=$(cat .agent-sessions/JUDGE_1_${task_id}_initial_SESSION_ID.txt 2>/dev/null)
    local session_2=$(cat .agent-sessions/JUDGE_2_${task_id}_initial_SESSION_ID.txt 2>/dev/null)
    local session_3=$(cat .agent-sessions/JUDGE_3_${task_id}_initial_SESSION_ID.txt 2>/dev/null)
    
    if [ -z "$session_1" ] || [ -z "$session_2" ] || [ -z "$session_3" ]; then
        print_error "Could not find initial panel session IDs for task: $task_id"
        echo ""
        echo "Make sure you've run the initial panel first:"
        echo "  cube panel $task_id <panel-prompt.md> initial"
        echo ""
        echo "Session files expected:"
        echo "  .agent-sessions/JUDGE_1_${task_id}_initial_SESSION_ID.txt"
        echo "  .agent-sessions/JUDGE_2_${task_id}_initial_SESSION_ID.txt"
        echo "  .agent-sessions/JUDGE_3_${task_id}_initial_SESSION_ID.txt"
        echo ""
        echo "Or use --fresh to launch new judges instead"
        exit 1
    fi
    
    print_info "Resuming original judge panel for peer review of task: $task_id"
    print_info "Using initial panel session IDs"
    echo ""
    
    # Fetch latest changes from writer branches
    print_info "Fetching latest changes from writer branches..."
    git fetch --all --quiet 2>/dev/null || true
    
    # Show current branch commits
    if git rev-parse --verify "writer-sonnet/$task_id" >/dev/null 2>&1; then
        local sonnet_commit=$(git rev-parse --short "writer-sonnet/$task_id" 2>/dev/null)
        echo -e "  ${GREEN}üìç writer-sonnet/$task_id: $sonnet_commit${NC}"
    fi
    
    if git rev-parse --verify "writer-codex/$task_id" >/dev/null 2>&1; then
        local codex_commit=$(git rev-parse --short "writer-codex/$task_id" 2>/dev/null)
        echo -e "  ${BLUE}üìç writer-codex/$task_id: $codex_commit${NC}"
    fi
    echo ""
    
    # Read peer review prompt
    local prompt_content=$(cat "$peer_review_prompt")
    
    # Create temp files for the prompt (one per judge)
    local temp_prompt_1=$(mktemp)
    local temp_prompt_2=$(mktemp)
    local temp_prompt_3=$(mktemp)
    echo "$prompt_content" > "$temp_prompt_1"
    echo "$prompt_content" > "$temp_prompt_2"
    echo "$prompt_content" > "$temp_prompt_3"
    
    # Cleanup on exit
    trap "rm -f $temp_prompt_1 $temp_prompt_2 $temp_prompt_3" EXIT
    
    print_success "Resuming 3 judges from initial panel"
    echo ""
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo "‚öñÔ∏è  JUDGES: Review the latest code from writer branches"
    echo "   Use: git diff main...writer-sonnet/$task_id"
    echo "   Use: git diff main...writer-codex/$task_id"
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo ""
    
    export PROJECT_ROOT
    
    # Create unique log files
    TIMESTAMP=$(date +%s)
    LOG_FILE_1="/tmp/judge-1-$task_id-peer-review-$TIMESTAMP.json"
    LOG_FILE_2="/tmp/judge-2-$task_id-peer-review-$TIMESTAMP.json"
    LOG_FILE_3="/tmp/judge-3-$task_id-peer-review-$TIMESTAMP.json"
    touch "$LOG_FILE_1" "$LOG_FILE_2" "$LOG_FILE_3"
    
    # Resume Judge 1 (Sonnet) - green
    (
        set +e
        cursor-agent --print --force --output-format stream-json --stream-partial-output \
            --model sonnet-4.5-thinking \
            --resume "$session_1" "$(cat $temp_prompt_1)" 2>&1 | tee "$LOG_FILE_1" | \
        jq -rR --unbuffered --arg project_root "$PROJECT_ROOT" '
            try (fromjson |
            def truncate_path:
                . as $path |
                if ($path | type) == "string" then
                    if ($path | test("/.cursor/worktrees/[^/]+/[^/]+/")) then
                        $path | sub(".*/\\.cursor/worktrees/[^/]+/[^/]+/"; "~worktrees/")
                    else
                        ("^" + ($project_root | gsub("[.^$*+?()\\[\\]{}|]"; "\\\\&")) + "/?") as $pattern |
                        $path | sub($pattern; "")
                    end
                else $path end;
            
            def format_duration:
                . as $ms |
                if $ms < 1000 then "\($ms)ms"
                elif $ms < 60000 then "\(($ms / 1000 | floor))s"
                else "\(($ms / 60000 | floor))m \((($ms % 60000) / 1000 | floor))s"
                end;
            
            if .type == "system" and .subtype == "init" then "\u001b[32m[Judge 1]\u001b[0m ü§ñ \(.model)"
            elif .type == "assistant" then
                if (.message.content[0].text // "") != "" and (.message.content[0].text | length) > 50 then "\u001b[32m[Judge 1]\u001b[0m üí≠ \(.message.content[0].text)"
                else empty end
            elif .type == "tool_call" then
                if .subtype == "started" then
                    if .tool_call.shellToolCall then
                        ((.tool_call.shellToolCall.args.command // "unknown") | sub("^cd [^ ]+ && "; "") | truncate_path) as $cmd |
                        if ($cmd | length) > 60 then "\u001b[32m[Judge 1]\u001b[0m üîß \($cmd[:57])..."
                        else "\u001b[32m[Judge 1]\u001b[0m üîß \($cmd)" end
                    elif .tool_call.readToolCall then
                        ((.tool_call.readToolCall.args.path // "unknown") | truncate_path) as $p |
                        if ($p | length) > 50 then "\u001b[32m[Judge 1]\u001b[0m üìñ \($p[:47])..."
                        else "\u001b[32m[Judge 1]\u001b[0m üìñ \($p)" end
                    else empty end
                elif .subtype == "completed" then
                    if .tool_call.shellToolCall.result.success then
                        if (.tool_call.shellToolCall.result.success.exitCode // 0) != 0 then
                            "\u001b[32m[Judge 1]\u001b[0m    ‚ùå Exit: \(.tool_call.shellToolCall.result.success.exitCode)"
                        else empty end
                    elif .tool_call.readToolCall.result.success then "\u001b[32m[Judge 1]\u001b[0m    ‚úÖ \(.tool_call.readToolCall.result.success.totalLines // 0) lines"
                    else empty end
                else empty end
            elif .type == "result" then "\u001b[32m[Judge 1]\u001b[0m üéØ Completed in \((.duration_ms // 0) | format_duration)"
            else empty end
            ) catch ("\u001b[32m[Judge 1]\u001b[0m ‚ö†Ô∏è  Invalid JSON: " + .)
        '
    ) &
    JUDGE_1_PID=$!
    
    # Resume Judge 2 (Codex) - yellow
    (
        set +e
        cursor-agent --print --force --output-format stream-json --stream-partial-output \
            --model gpt-5-codex-high \
            --resume "$session_2" "$(cat $temp_prompt_2)" 2>&1 | tee "$LOG_FILE_2" | \
        jq -rR --unbuffered --arg project_root "$PROJECT_ROOT" '
            try (fromjson |
            def truncate_path:
                . as $path |
                if ($path | type) == "string" then
                    if ($path | test("/.cursor/worktrees/[^/]+/[^/]+/")) then
                        $path | sub(".*/\\.cursor/worktrees/[^/]+/[^/]+/"; "~worktrees/")
                    else
                        ("^" + ($project_root | gsub("[.^$*+?()\\[\\]{}|]"; "\\\\&")) + "/?") as $pattern |
                        $path | sub($pattern; "")
                    end
                else $path end;
            
            def format_duration:
                . as $ms |
                if $ms < 1000 then "\($ms)ms"
                elif $ms < 60000 then "\(($ms / 1000 | floor))s"
                else "\(($ms / 60000 | floor))m \((($ms % 60000) / 1000 | floor))s"
                end;
            
            if .type == "system" and .subtype == "init" then "\u001b[33m[Judge 2]\u001b[0m ü§ñ \(.model)"
            elif .type == "assistant" then
                if (.message.content[0].text // "") != "" and (.message.content[0].text | length) > 50 then "\u001b[33m[Judge 2]\u001b[0m üí≠ \(.message.content[0].text)"
                else empty end
            elif .type == "tool_call" then
                if .subtype == "started" then
                    if .tool_call.shellToolCall then
                        ((.tool_call.shellToolCall.args.command // "unknown") | sub("^cd [^ ]+ && "; "") | truncate_path) as $cmd |
                        if ($cmd | length) > 60 then "\u001b[33m[Judge 2]\u001b[0m üîß \($cmd[:57])..."
                        else "\u001b[33m[Judge 2]\u001b[0m üîß \($cmd)" end
                    elif .tool_call.readToolCall then
                        ((.tool_call.readToolCall.args.path // "unknown") | truncate_path) as $p |
                        if ($p | length) > 50 then "\u001b[33m[Judge 2]\u001b[0m üìñ \($p[:47])..."
                        else "\u001b[33m[Judge 2]\u001b[0m üìñ \($p)" end
                    else empty end
                elif .subtype == "completed" then
                    if .tool_call.shellToolCall.result.success then
                        if (.tool_call.shellToolCall.result.success.exitCode // 0) != 0 then
                            "\u001b[33m[Judge 2]\u001b[0m    ‚ùå Exit: \(.tool_call.shellToolCall.result.success.exitCode)"
                        else empty end
                    elif .tool_call.readToolCall.result.success then "\u001b[33m[Judge 2]\u001b[0m    ‚úÖ \(.tool_call.readToolCall.result.success.totalLines // 0) lines"
                    else empty end
                else empty end
            elif .type == "result" then "\u001b[33m[Judge 2]\u001b[0m üéØ Completed in \((.duration_ms // 0) | format_duration)"
            else empty end
            ) catch ("\u001b[33m[Judge 2]\u001b[0m ‚ö†Ô∏è  Invalid JSON: " + .)
        '
    ) &
    JUDGE_2_PID=$!
    
    # Resume Judge 3 (Grok) - magenta
    (
        set +e
        cursor-agent --print --force --output-format stream-json --stream-partial-output \
            --model grok \
            --resume "$session_3" "$(cat $temp_prompt_3)" 2>&1 | tee "$LOG_FILE_3" | \
        jq -rR --unbuffered --arg project_root "$PROJECT_ROOT" '
            try (fromjson |
            def truncate_path:
                . as $path |
                if ($path | type) == "string" then
                    if ($path | test("/.cursor/worktrees/[^/]+/[^/]+/")) then
                        $path | sub(".*/\\.cursor/worktrees/[^/]+/[^/]+/"; "~worktrees/")
                    else
                        ("^" + ($project_root | gsub("[.^$*+?()\\[\\]{}|]"; "\\\\&")) + "/?") as $pattern |
                        $path | sub($pattern; "")
                    end
                else $path end;
            
            def format_duration:
                . as $ms |
                if $ms < 1000 then "\($ms)ms"
                elif $ms < 60000 then "\(($ms / 1000 | floor))s"
                else "\(($ms / 60000 | floor))m \((($ms % 60000) / 1000 | floor))s"
                end;
            
            if .type == "system" and .subtype == "init" then "\u001b[35m[Judge 3]\u001b[0m ü§ñ \(.model)"
            elif .type == "assistant" then
                if (.message.content[0].text // "") != "" and (.message.content[0].text | length) > 50 then "\u001b[35m[Judge 3]\u001b[0m üí≠ \(.message.content[0].text)"
                else empty end
            elif .type == "tool_call" then
                if .subtype == "started" then
                    if .tool_call.shellToolCall then
                        ((.tool_call.shellToolCall.args.command // "unknown") | sub("^cd [^ ]+ && "; "") | truncate_path) as $cmd |
                        if ($cmd | length) > 60 then "\u001b[35m[Judge 3]\u001b[0m üîß \($cmd[:57])..."
                        else "\u001b[35m[Judge 3]\u001b[0m üîß \($cmd)" end
                    elif .tool_call.readToolCall then
                        ((.tool_call.readToolCall.args.path // "unknown") | truncate_path) as $p |
                        if ($p | length) > 50 then "\u001b[35m[Judge 3]\u001b[0m üìñ \($p[:47])..."
                        else "\u001b[35m[Judge 3]\u001b[0m üìñ \($p)" end
                    else empty end
                elif .subtype == "completed" then
                    if .tool_call.shellToolCall.result.success then
                        if (.tool_call.shellToolCall.result.success.exitCode // 0) != 0 then
                            "\u001b[35m[Judge 3]\u001b[0m    ‚ùå Exit: \(.tool_call.shellToolCall.result.success.exitCode)"
                        else empty end
                    elif .tool_call.readToolCall.result.success then "\u001b[35m[Judge 3]\u001b[0m    ‚úÖ \(.tool_call.readToolCall.result.success.totalLines // 0) lines"
                    else empty end
                else empty end
            elif .type == "result" then "\u001b[35m[Judge 3]\u001b[0m üéØ Completed in \((.duration_ms // 0) | format_duration)"
            else empty end
            ) catch ("\u001b[35m[Judge 3]\u001b[0m ‚ö†Ô∏è  Invalid JSON: " + .)
        '
    ) &
    JUDGE_3_PID=$!
    
    echo "üìä Judge 1 (Sonnet) resumed: PID $JUDGE_1_PID"
    echo "üìä Judge 2 (Codex) resumed: PID $JUDGE_2_PID"
    echo "üìä Judge 3 (Grok) resumed: PID $JUDGE_3_PID"
    echo ""
    echo "‚è≥ Waiting for all 3 judges to complete peer review..."
    echo ""
    
    # Wait for all
    wait $JUDGE_1_PID; JUDGE_1_EXIT=$?
    wait $JUDGE_2_PID; JUDGE_2_EXIT=$?
    wait $JUDGE_3_PID; JUDGE_3_EXIT=$?
    
    echo ""
    echo "‚úÖ Judge 1 completed with exit code: $JUDGE_1_EXIT"
    echo "‚úÖ Judge 2 completed with exit code: $JUDGE_2_EXIT"
    echo "‚úÖ Judge 3 completed with exit code: $JUDGE_3_EXIT"
    echo ""
    
    print_success "Peer review complete!"
}

# Orchestrate command - generate orchestrator prompt
cmd_orchestrate() {
    local subcommand="$1"
    
    if [ "$subcommand" != "prompt" ]; then
        print_error "Unknown orchestrate subcommand: $subcommand"
        echo ""
        echo "Usage: cube orchestrate prompt <task-file> [--copy]"
        exit 1
    fi
    
    shift
    local task_file="$1"
    local copy_flag="$2"
    
    if [ -z "$task_file" ]; then
        print_error "Task file is required"
        echo ""
        echo "Usage: cube orchestrate prompt <task-file> [--copy]"
        exit 1
    fi
    
    if [ ! -f "$task_file" ]; then
        print_error "Task file not found: $task_file"
        exit 1
    fi
    
    # Read task file content
    local task_content=$(cat "$task_file")
    local task_filename=$(basename "$task_file")
    
    # Generate orchestrator prompt
    local prompt="# Agent Cube Orchestrator

You are an autonomous orchestrator for the Agent Cube parallel LLM coding workflow. Your goal is to complete the entire workflow from task spec to merged PR.

## Task to Orchestrate

**Task File:** \`$task_file\`

\`\`\`markdown
$task_content
\`\`\`

## Your Capabilities

You can execute cube CLI commands by running them in your terminal. Available commands:

- \`cube writers <task-id> <writer-prompt-file>\` - Launch dual writers
- \`cube panel <task-id> <panel-prompt-file> initial\` - Launch initial review panel (3 new judges)
- \`cube peer-review <task-id> <peer-review-prompt-file>\` - Resume original 3 judges for peer review
- \`cube feedback <writer> <task-id> <feedback-file>\` - Send feedback to writer
- \`cube status\` - Check active agent sessions
- \`cube sessions\` - List all session IDs

## Workflow Phases

### Phase 1: Dual Writer Launch
1. Generate a comprehensive writer prompt in \`/tmp/writer-prompt-\${task-id}.md\`
2. Run: \`cube writers <task-id> /tmp/writer-prompt-\${task-id}.md\`
3. Wait for completion (watch terminal output)
4. Read writer outputs from their worktrees:
   - Writer A (Sonnet): \`~/.cursor/worktrees/\${project}/writer-sonnet-\${task-id}/\`
   - Writer B (Codex): \`~/.cursor/worktrees/\${project}/writer-codex-\${task-id}/\`

### Phase 2: Initial Review Panel
1. Analyze both writer outputs
2. Compare against task requirements and planning docs
3. Generate panel prompt in \`/tmp/panel-prompt-\${task-id}.md\`
4. Run: \`cube panel <task-id> /tmp/panel-prompt-\${task-id}.md initial\`
5. Wait for 3 judges to complete
6. Read judge reviews from \`.agent-sessions/JUDGE_*_\${task-id}_*\`

### Phase 3: Decision Making
Based on judge votes, decide:
- **If consensus APPROVE**: Pick winning writer, proceed to synthesis/peer-review
- **If REQUEST_CHANGES**: Generate feedback, loop back to writer
- **If MIXED**: Analyze concerns, decide on synthesis vs feedback

### Phase 4: Synthesis (if needed)
1. If both writers have valuable contributions, merge best parts
2. Generate synthesis instructions
3. Resume winning writer with synthesis prompt

### Phase 5: Peer Review
1. Generate peer review prompt in \`/tmp/peer-review-\${task-id}.md\`
2. Run: \`cube peer-review <task-id> /tmp/peer-review-\${task-id}.md\`
3. Original 3 judges verify their concerns were addressed
4. Interpret final votes

### Phase 6: PR Creation
1. If approved, create PR:
   - Use winning writer's branch
   - Write comprehensive PR description
   - Reference task file and review decisions
2. Run git commands to create PR
3. Update Jira ticket (if task ID provided)

## Important Rules

1. **Generate prompts dynamically** - Don't use hardcoded prompts, generate them based on:
   - Task requirements
   - Planning docs (read from \`planning/\` directory)
   - Current state of the workflow

2. **Read actual outputs** - Don't assume, read the actual files from:
   - Writer worktrees
   - Judge session files
   - Git diffs

3. **Explain your reasoning** - Before each command, explain why you're doing it

4. **Handle failures gracefully** - If something fails, diagnose and retry or adjust

5. **Use actual project context** - Reference real planning docs, not invented ones

6. **Be thorough** - Don't skip steps; this is production code

## Available Context

- **Project root**: \`$PROJECT_ROOT\`
- **Task file**: \`$task_file\`
- **Planning docs**: \`planning/\` directory
- **Agent Cube docs**: \`AGENT_CUBE.md\` for workflow patterns

## Your First Step

Start by:
1. Reading relevant planning docs for this task
2. Understanding the acceptance criteria
3. Generating the writer prompt
4. Launching the dual writers

Begin orchestration now!"

    # Output or copy to clipboard
    if [ "$copy_flag" = "--copy" ]; then
        # Detect OS and copy to clipboard
        if command -v pbcopy &> /dev/null; then
            # macOS
            echo "$prompt" | pbcopy
            print_success "Orchestrator prompt copied to clipboard!"
        elif command -v xclip &> /dev/null; then
            # Linux with xclip
            echo "$prompt" | xclip -selection clipboard
            print_success "Orchestrator prompt copied to clipboard!"
        elif command -v xsel &> /dev/null; then
            # Linux with xsel
            echo "$prompt" | xsel --clipboard --input
            print_success "Orchestrator prompt copied to clipboard!"
        elif [ -n "$WSL_DISTRO_NAME" ] || command -v clip.exe &> /dev/null; then
            # WSL
            echo "$prompt" | clip.exe
            print_success "Orchestrator prompt copied to clipboard!"
        else
            print_warning "No clipboard utility found. Printing to stdout instead."
            echo "$prompt"
        fi
    else
        echo "$prompt"
    fi
}

# Main command dispatcher
main() {
    if [ $# -eq 0 ]; then
        show_help
        exit 0
    fi
    
    case "$1" in
        -h|--help|help)
            show_help
            ;;
        -v|--version|version)
            show_version
            ;;
        install)
            install_cube
            ;;
        writers)
            shift
            cmd_writers "$@"
            ;;
        panel)
            shift
            cmd_panel "$@"
            ;;
        peer-review)
            shift
            cmd_peer_review "$@"
            ;;
        feedback)
            shift
            cmd_feedback "$@"
            ;;
        status)
            shift
            cmd_status "$@"
            ;;
        sessions)
            cmd_sessions
            ;;
        resume)
            shift
            cmd_resume "$@"
            ;;
        orchestrate)
            shift
            cmd_orchestrate "$@"
            ;;
        *)
            print_error "Unknown command: $1"
            echo ""
            echo "Run 'cube help' for usage information"
            exit 1
            ;;
    esac
}

# Run main
main "$@"

